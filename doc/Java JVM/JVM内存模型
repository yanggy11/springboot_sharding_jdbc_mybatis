1.线程私有内存区域：声明周期同线程
    1）程序计数器：线程执行的指令的地址，无异常抛出
    2）本地方法栈：native方法运行时的数据，同虚拟机栈。
    3）虚拟机栈：存储Java方法运行时的引用和基本类型数据，为每个方法创建一个栈帧，包括：操作数栈、局部变量表、动态链接、返回信息，使用连续的内存空间。
        异常：
            1）当线程请求的栈深度超过虚拟机允许的栈深度时，抛出StackOverflowError异常
            2）当无法扩展栈内存时，抛出OutOfMemoryError异常。

2.线程共享内存区域：GC主要回收的内存区域。
    1）堆区：存储运行时各种对象的实例、数组等，即new出来的对象实例，可以使用不连续的内存空间。
        新生代：
        老年代：多次GC存活的对象会被转移到老年代
        异常：当无法分配内存，且无法扩展内存时，抛出OutOfMemoryError异常。
    2）方法区：存储类加载时的信息、常量池、静态变量以及编译后的代码数据等，可以使用不连续的内存空间。
        1）方法常量区：存储编译时产生的符号引用和各种字面量，以及运行时产生的常量(通过String.intern方法转换)
        2）异常：当常量区需要分配内存且不够时，会抛出OutOrMemoryError异常。

3.堆与栈的比较：
        堆很灵活，但是不安全。对于对象，我们要动态地创建、销毁，不能说后创建的对象没有销毁，先前创建的对象就不能销毁，
    那样的话我们的程序就寸步难行，所以Java中用堆来存储对象。而一旦堆中的对象被销毁，我们继续引用这个对象的话，
    就会出现著名的NullPointerException，这就是堆的缺点——错误的引用逻辑只有在运行时才会被发现。
        栈不灵活，但是很严格，是安全的，易于管理。因为只要上面的引用没有销毁，下面引用就一定还在，在大部分程序中，
    都是先定义的变量、引用先进栈，后定义的后进栈，同时，区块内部的变量、引用在进入区块时压栈，区块结束时出栈，
    理解了这种机制，我们就可以很方便地理解各种编程语言的作用域的概念了，同时这也是栈的优点——错误的引用逻辑在编译
    时就可以被发现。

    栈--主要存放引用和基本数据类型。
    堆--用来存放 new 出来的对象实例。

4.内存溢出与泄露
    内存溢出：当申请内存时，没有足够的内存进行分配，会出现内存溢出。
    内存泄露：无法释放已经分配的内存空间，会导致内存泄露。内存泄露最终会导致内存溢出。

